[TOC]

结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字下。

结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值。



# 1 结构的基本知识

结构声明：

```
struct point {
    int x;
    int y;
};
```

关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。

上述代码声明了一个**结构标记**（即结构名称）为 point 的结构，结构标记是可选的，并不是必需的。结构中定义了 x、y两个**成员**。

如果结构声明的后面不带变量表，则不需要为它们分配存储空间，它仅仅描述了一个结构模板或轮廓。



结构可以嵌套。可以通过 “结构名.成员” 的形式引用结构中的成员。如：

```
-------------源代码--------------
struct point {
    int x;
    int y;
};

struct rect {
    struct point p1;
    struct point p2;
};

int main() {
    struct point p1 = {0, 0};
    struct point p2 = {100, 100};
    struct rect r = {p1, p2};
    printf("p1.x = %d\n", p1.x);
    printf("p2.x = %d\n", p2.x);
    printf("r.p1.x = %d\n", r.p1.x);
    printf("r.p2.x = %d\n", r.p2.x);
    return 0;
}

-----------程序输出-----------
p1.x = 0
p2.x = 100
r.p1.x = 0
r.p2.x = 100
```



# 2 结构与函数

结构的合法操作只有以下几种：

- 作为一个整体复制和赋值。

- 通过&运算符获取地址。

  包括向函数传递参数和从函数返回值。

- 访问其成员



结构之间不可以进行比较。



在函数调用时，结构类型的参数和其他类型的参数一样，都是通过值传递的。

示例代码：

```
--------------源代码--------------
struct point {
    int x;
    int y;
};

void change(struct point p) {
    p.x = 3;
    p.y = 4;
}

int main() {
    struct point p = {1, 2};
    printf("p.x = %d\n", p.x);
    printf("p.y = %d\n", p.y);
    change(p);
    printf("p.x = %d\n", p.x);
    printf("p.y = %d\n", p.y);
    return 0;
}

--------------源程序输出--------------
p.x = 1
p.y = 2
p.x = 1
p.y = 2
```



如果传递给函数的结构很大，使用指针方式的效率通常比赋值整个结构的效率要高。

修改上述代码：

```
--------------源代码--------------
struct point {
    int x;
    int y;
};

void change(struct point *p) {
    (*p).x = 3;
    p->y = 4;
}

int main() {
    struct point p = {1, 2};
    printf("p.x = %d\n", p.x);
    printf("p.y = %d\n", p.y);
    change(&p);
    printf("p.x = %d\n", p.x);
    printf("p.y = %d\n", p.y);
    return 0;
}

--------------程序输出--------------
p.x = 1
p.y = 2
p.x = 3
p.y = 4
```

为了方便结构指针的使用，C语言提供了 “指针名->结构成员” 的简写方式来引用结构成员（上述代码中 change 方法体内展示了2种通过结构指针引用结构成员的方式）。



在使用结构指针时，一定要注意运算符的优先级。在所有的运算符中，下面4个运算符的优先级最高：结构运算符 "." 和 "->"、用于函数调用的 "()"、用于下标的 "[]"。

```
--------------源代码--------------
struct point {
    int x;
    int y;
};

int main() {
    struct point p = {1, 2};
    struct point *pp = &p;
    printf("p.x = %d\n", p.x);
    ++pp->x;
    printf("p.x = %d\n", p.x);
    return 0;
}

--------------程序输出--------------
p.x = 1
p.x = 2
```

在上述代码中，表达式 `++pp->x`将增加x的值，而不是增加指针 pp 的值，这是因为 "++" 运算符的优先级要低于 "->"。



# 3 结构数组

声明结构数组：

```
struct point {
    int x;
    int y;
} points[10];
```

上述代码声明了一个结构类型point，并定义了该类型的结构数组 points，同时为其分配存储空间。



C语言提供了一个编译时一元运算符 **sizeof**，它可以用来计算任意对象或者类型的长度，即占用的存储空间字节数。

```
--------------源代码--------------
struct point {
    int x;
    int y;
};

int main() {
    struct point p = {1, 2};
    printf("sizeof p = %d\n", sizeof p);
    printf("sizeof point = %d\n", sizeof(struct point));
    return 0;
}

--------------程序输出--------------
sizeof p = 8
sizeof point = 8
```

从上述代码的程序输出也可看出，结构类型声明时如果指定了变量表，那么就会直接分配内存。如果没有指定变量表，调用 sizeof 是无法通过编译的，sizeof 只能作用于已经分配了内存的变量或者类型。



注意：**条件编译语句 #if 中不能使用 sizeof**，因为预处理器不对类型名进行分析。但预处理并不计算 #define 语句中的表达式，所以，**在 #define 中使用 sizeof 是合法的**。



# 4 自引用结构

一个包含自身实例的结构是非法的，如：

```
struct point {
    int x;
    int y;
    struct point nextPoint;
};
```



但是，一个包含自身结构指针的结构是合法的。

```
struct point {
    int x;
    int y;
    struct point *nextPoint;
};
```



# 5 类型定义（typeof）

C语言提供了一个成为 typeof 的功能，它用来建立新的数据类型名。例如，声明

```
typeof int Length;
```

将 Length 定义为与 int 具有同等意义的名字。



下面为 typeof 更为复杂一些的用法：

```
typedef struct point *Pointp;

typedef struct point {
    int x;
    int y;
    struct point *nextPoint;
} Point;
```



typeof 声明并没有创建一个新类型，它只是为某个已经存在的类型添加了一个新的名称而已。

typeof 声明也没有添加任何新的语义，通过这种方式声明的变量与通过声明方式声明的变量具有完全相同的属性。

实际上，typeof 类似于 #define 语句，但由于 typeof 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。



# 6 联合

联合是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对其要求。联合提供了一种方式，以在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。



声明一个联合：

```
union u_demo {
    int ival;
    float fval;
    char sval[10];
};
```



访问联合中的成员与访问结构的方式相同，可以通过 ”联合名.成员“ 和 ”联合指针->成员“ 方式。



联合可以使用在结构和数组中，如：

```
struct {
	char *name;
	int flags;
	int utype;
	union {
		int ival;
		float fval;
		char *sval;
	} u;
} symtab[10];
```



实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都为0，此结构空间要大到足够容纳最”宽“的成员，并且，其对齐方式要适合于联合中所有类型的成员。

联合只能用其第一个成员类型的值进行初始化。



# 7 位字段

C语言提供了直接定义和访问一个字中位字段的能力。位字段，或者简称字段，是”字“中相邻位的集合，”字“是单个的存储单元，它和具体的实现有关。



```
struct {
	unsigned int is_keyword : 1;
	unsigned int is_extern : 1;
	unsigned int is_static : 1;
}
```

上述代码中定义了一个变量 flag，它包含3个一位的字段。冒号后的数字表示字段的宽度（用二进制位数表示）。



单个字段的引用方式与其他结构成员相同，字段可出现在算数表达式中。

字段的所有属性几乎都同具体的实现有关。字段可以不命名，无名字段（只有一个冒号和宽度）其填充作用。特殊字段0可以强制在下一个字边界上对齐。

某些机器上字段的分配是从从字的左端至右端进行的，而某些机器上则相反。所以，依赖于这些因素的程序是不可移植的。字段只能声明位int类型，为了便于一直，需要显示声明是 signed 还是 unsigned 类型。字段不是数组，并且没有地址，不可以使用 & 运算符。
