[TOC]

指针是一种保存变量地址的**变量**。



# 1 指针与地址

指针是能够存放一个地址的一组存储单元（通常是2个或者4个字节）。



一元运算符 **&** 可用于取一个对象的地址，下列语句：

```
p = &c;
```

将把c的地址赋值给变量p，称p为“指向”c的指针。

地址运算符 & 只能应用于内存中的变量，即变量与数组元素。它不能作用于表达式、常量或者register类型的变量。



一元运算符 * 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。尝试运行以下代码：

```
int main() {
    int a = 1;
    int *p;
    p = &a;
    printf("*p = %d \n", *p);
    printf("a = %d \n", a);
    printf("-------------------\n");
    *p = 2;
    printf("*p = %d \n", *p);
    printf("a = %d \n", a);
    return 0;
}
```

程序输出：

```
*p = 1 
a = 1 
-------------------
*p = 2 
a = 2 
```

p = &a 使得p指向a，*p = 2 修改p所指向对象的值，即 a 的值。



指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型（一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）。



一元运算符 ***** 和 **&** 的优先级比算术运算符的优先级高：

```
---------源代码-----------
int main() {
    int a = 1, y;
    int *p;
    p = &a;
    y = *p + 1;
    printf("y = %d \n", y);
    return 0;
}

---------程序输出----------
y = 2 
```

**\*** 和 **++**、**--** 这样的一元运算符遵循从右到左的结合顺序：

```
---------源代码1-----------
int main() {
    int a = 1;
    int *p;
    p = &a;
    printf("%d \n", ++*p);
    return 0;
}

---------程序输出----------
2 

---------源代码2-----------
int main() {
    int a = 1;
    int *p;
    p = &a;
    printf("%d \n", *p++);
    return 0;
}

---------程序输出----------
1 
```



# 2 指针与函数参数

C语言是以传值的方式将参数值传递给被调用函数，被调用函数不能直接修改主调函数中变量的值。

```
---------源代码-----------
void change(int a, int b) {
    a = 2;
    b = 3;
}

int main() {
    int a = 1, b = 2;
    change(a, b);
    printf("a = %d \n", a);
    printf("b = %d \n", b);
    return 0;
}

---------程序输出----------
a = 1 
b = 2
```



指针参数使得被调函数能够访问和修改主调函数中对象的值。

```
---------源代码-----------
void change(int *pa, int *pb) {
    *pa = 2;
    *pb = 3;
}

int main() {
    int a = 1, b = 2;
    change(&a, &b);
    printf("a = %d \n", a);
    printf("b = %d \n", b);
    return 0;
}

---------程序输出----------
a = 2 
b = 3
```



# 3 指针与数组

一般来说，用指针编写的程序比用数组下标编写的程序执行速度快。



如果指针p指向数组中的某个特定元素，那么，根据指针运算的定义，p+1 将指向下一个元素，p+i 将指向p所指向元素之后的第i个元素。

```
---------源代码-----------
int main() {
    int arr[5] = {0, 1, 2, 3, 4};
    int *p;
    int x;
    p = &arr[0];
    x = *p;
    printf("x = %d \n", x);
    p += 3;
    x = *p;
    printf("x = %d \n", x);
    return 0;
}

---------程序输出----------
x = 0 
x = 3
```



数组下标和指针运算之间具有密切的对应关系。根据定义，数组类型的变量或表达式的值是该数组第0个元素的地址。执行赋值语句：

```
pa = &a[0];
```

后，pa和a具有相同的值。因为数组名所代表的就是该数组最开始第一个元素的地址，所以，上述语句也可以写成以下形式：

```
pa = a;
```

对数组元素 a[i] 的引用也可以写成 *(a + i) 这种形式。在计算 a[i] 的值时，C语言实际上先将其转换为 *(a + i) 的形式，然后再进行求值，因此这两种写法是等价的。同理，&a[i] 与 a+i 也是等价的。

如果pa是一个指针，那么，在表达式中也可以在它的后面加下标。pa[i] 与 *(pa + i) 是等价的。简而言之，一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。



数组名和指针之间有一个不同之处：指针是一个变量。因此，在C语言中，语句 pa=a 和 pa++ 都是合法的，但是数组名不是变量，类似于 a=pa 和 a++ 形式的语句都是非法的。



在函数定义中，以下两种写法是等价的：

```
int f(char s[]);
```

```
int f(char *s);
```

通常更习惯于使用第二种方式，它比前者更直观地表明了该参数是一个指针。



# 4 地址算数运算

有效的指针运算包括以下4种情况：

1. 相同类型指针之间的赋值运算

   ```
   int main() {
       int a = 1;
       int *pa, *pb;
       char *pc;
       pa = &a;
       pb = pa;	// 正确
       pc = pa;	// 错误
       return 0;
   }
   ```

2. 指针同整数之间的加法或减法运算

   ```
   int main() {
       int a = 1;
       int *pa;
       pa = &a;
       pa = pa + 2;	// 正确
       pa = pa - 2;	// 正确
       pa = pa * 2;	// 错误
       pa = pa / 2;	// 错误
       return 0;
   }
   ```

3. 指向相同数组中元素的两个指针间的减法或者比较运算

   ```
   int main() {
       int a[5] = {0, 1, 2, 3, 4};
       int *pa, *pb;
       pa = &a[0];
       pb = &a[2];
       int c = pb - pa;	// 正确
       int d = pb > pa;	// 正确
       int e = pb + pa;	// 错误
       return 0;
   }
   ```

4. 将指针赋值为0或指针与0之间的比较运算

   ```
   int main() {
       int *pa;
       pa = 0;		// 正确
       pa > 0;		// 正确
       pa = 1;		// 错误
       pa > 1;		// 错误
       return 0;
   }
   ```

   