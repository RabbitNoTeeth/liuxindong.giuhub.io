[TOC]

指针是一种保存变量地址的**变量**。



# 1 指针与地址

指针是能够存放一个地址的一组存储单元（通常是2个或者4个字节）。



一元运算符 **&** 可用于取一个对象的地址，下列语句：

```
p = &c;
```

将把c的地址赋值给变量p，称p为“指向”c的指针。

地址运算符 & 只能应用于内存中的变量，即变量与数组元素。它不能作用于表达式、常量或者register类型的变量。



一元运算符 * 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。尝试运行以下代码：

```
int main() {
    int a = 1;
    int *p;
    p = &a;
    printf("*p = %d \n", *p);
    printf("a = %d \n", a);
    printf("-------------------\n");
    *p = 2;
    printf("*p = %d \n", *p);
    printf("a = %d \n", a);
    return 0;
}
```

程序输出：

```
*p = 1 
a = 1 
-------------------
*p = 2 
a = 2 
```

p = &a 使得p指向a，*p = 2 修改p所指向对象的值，即 a 的值。



指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型（一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）。



一元运算符 ***** 和 **&** 的优先级比算术运算符的优先级高：

```
---------源代码-----------
int main() {
    int a = 1, y;
    int *p;
    p = &a;
    y = *p + 1;
    printf("y = %d \n", y);
    return 0;
}

---------程序输出----------
y = 2 
```

**\*** 和 **++**、**--** 这样的一元运算符遵循从右到左的结合顺序：

```
---------源代码1-----------
int main() {
    int a = 1;
    int *p;
    p = &a;
    printf("%d \n", ++*p);
    return 0;
}

---------程序输出----------
2 

---------源代码2-----------
int main() {
    int a = 1;
    int *p;
    p = &a;
    printf("%d \n", *p++);
    return 0;
}

---------程序输出----------
1 
```



# 2 指针与函数参数

C语言是以传值的方式将参数值传递给被调用函数，被调用函数不能直接修改主调函数中变量的值。

```
---------源代码-----------
void change(int a, int b) {
    a = 2;
    b = 3;
}

int main() {
    int a = 1, b = 2;
    change(a, b);
    printf("a = %d \n", a);
    printf("b = %d \n", b);
    return 0;
}

---------程序输出----------
a = 1 
b = 2
```



指针参数使得被调函数能够访问和修改主调函数中对象的值。

```
---------源代码-----------
void change(int *pa, int *pb) {
    *pa = 2;
    *pb = 3;
}

int main() {
    int a = 1, b = 2;
    change(&a, &b);
    printf("a = %d \n", a);
    printf("b = %d \n", b);
    return 0;
}

---------程序输出----------
a = 2 
b = 3
```



# 3 指针与数组

一般来说，用指针编写的程序比用数组下标编写的程序执行速度快。



如果指针p指向数组中的某个特定元素，那么，根据指针运算的定义，p+1 将指向下一个元素，p+i 将指向p所指向元素之后的第i个元素。

```
---------源代码-----------
int main() {
    int arr[5] = {0, 1, 2, 3, 4};
    int *p;
    int x;
    p = &arr[0];
    x = *p;
    printf("x = %d \n", x);
    p += 3;
    x = *p;
    printf("x = %d \n", x);
    return 0;
}

---------程序输出----------
x = 0 
x = 3
```



数组下标和指针运算之间具有密切的对应关系。根据定义，数组类型的变量或表达式的值是该数组第0个元素的地址。执行赋值语句：

```
pa = &a[0];
```

后，pa和a具有相同的值。因为数组名所代表的就是该数组最开始第一个元素的地址，所以，上述语句也可以写成以下形式：

```
pa = a;
```

对数组元素 a[i] 的引用也可以写成 *(a + i) 这种形式。在计算 a[i] 的值时，C语言实际上先将其转换为 *(a + i) 的形式，然后再进行求值，因此这两种写法是等价的。同理，&a[i] 与 a+i 也是等价的。

如果pa是一个指针，那么，在表达式中也可以在它的后面加下标。pa[i] 与 *(pa + i) 是等价的。简而言之，一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。



数组名和指针之间有一个不同之处：指针是一个变量。因此，在C语言中，语句 pa=a 和 pa++ 都是合法的，但是数组名不是变量，类似于 a=pa 和 a++ 形式的语句都是非法的。



在函数定义中，以下两种写法是等价的：

```
int f(char s[]);
```

```
int f(char *s);
```

通常更习惯于使用第二种方式，它比前者更直观地表明了该参数是一个指针。



# 4 地址算数运算

有效的指针运算包括以下4种情况：

1. 相同类型指针之间的赋值运算

   ```
   int main() {
       int a = 1;
       int *pa, *pb;
       char *pc;
       pa = &a;
       pb = pa;	// 正确
       pc = pa;	// 错误
       return 0;
   }
   ```

2. 指针同整数之间的加法或减法运算

   ```
   int main() {
       int a = 1;
       int *pa;
       pa = &a;
       pa = pa + 2;	// 正确
       pa = pa - 2;	// 正确
       pa = pa * 2;	// 错误
       pa = pa / 2;	// 错误
       return 0;
   }
   ```

3. 指向相同数组中元素的两个指针间的减法或者比较运算

   ```
   int main() {
       int a[5] = {0, 1, 2, 3, 4};
       int *pa, *pb;
       pa = &a[0];
       pb = &a[2];
       int c = pb - pa;	// 正确
       int d = pb > pa;	// 正确
       int e = pb + pa;	// 错误
       return 0;
   }
   ```

4. 将指针赋值为0或指针与0之间的比较运算

   ```
   int main() {
       int *pa;
       pa = 0;		// 正确
       pa > 0;		// 正确
       pa = 1;		// 错误
       pa > 1;		// 错误
       return 0;
   }
   ```




# 5 字符指针与函数

字符串常量可以通过一个指向第一个元素的指针访问。



执行以下代码：

```
---------源代码-----------
int main() {
    char *p = "now is the time";
    printf("p[0] = %c\n", p[0]);
    printf("p = %s\n", p);
    p[0] = 'a';
    printf("p[0] = %c\n", p[0]);
    printf("p = %s\n", p);
    printf("*p = %d", *p);
    return 0;
}

---------程序输出----------
p[0] = n
p = now is the time
p[0] = a
p = aow is the time
*p = 97
```



# 6 指针数组以及指向指针的指针

由于指针也是变量，所以它们也可以像其他变量一样存储在数组中。



声明指针数组：

```
char *p[50];
```

上述证明表示p是一个具有50个元素的一维数组，数组的每个元素都是一个指向字符类型对象的指针。

同时，由于p本身是一个数组名，所以，也可将其作为指针使用。



指针数组形参表示：

```
void f(char *p[]) {
    ...
}
```



# 7 多维数组

二维数组作为参数传递给函数时，函数的参数声明中必须指明数组的列数。



以下3种函数声明是等价的：

```
void f(int a[2][13]) { ... }
```

```
void f(int a[][13]) { ... }
```

```
void f(int (*a)[13]) { ... }
```



# 8 命令行参数

在支持C语言的环境中，可以在程序开始执行时将命令行参数传递给程序。

调用主函数main时，它带有2个参数：

1. 第一个参数（习惯上称为 argc，用于参数计数）的值表示运行程序时命令行中参数的数目。
2. 第二个参数（成为 argv，用于参数向量）是一个指向字符串数组的指针，其中每个字符对应一个参数。



按照C语言的约定，argv[0] 的值是启动该程序的程序名，因此 argc 的值至少为1。如果 argc 的值为1，说明程序名后面没有命令行参数。

另外，ANSI标准要求 argv[argc] 的值必须为一空指针。



# 9 指向函数的指针

在C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等。



**void *** 为通用指针类型，任何类型的指针都可以转换为 **void *** 类型，并且在将它转换回原来的类型时不会丢失信息。



声明一个指向函数的指针：

```
int (*fp)(void *, void *);
```

上述声明表示 fp 是一个指向函数的指针，该函数具有2个 void * 类型的参数，其返回值类型为 int。



通过指向函数的指针调用函数：

```
(*fp)(v[i], v[j]);
```

由于在函数声明时，该函数参数类型为 void *，所以可接受指向任意类型的指针。