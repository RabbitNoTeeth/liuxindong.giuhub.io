[TOC]



Spring事务的本质是数据库对事务的支持，如果数据库不支持事务，那么spring是无法提供事务管理的。



在jdbc中，使用事务是这样的：

```
//1.获取数据库连接
Connection connection = DriverManager.getConnection();

//2.开启事务
connection.setAutoCommit(false);

//3.执行crud
...

//4.根据执行结果,成功则提交,失败则回滚
connection.commit(); // connection.rollback();

//5.关闭连接
connection.close();
```

在使用Spring的事务管理后，spring为我们完成了步骤2和4，我们不再需要去显式的使用事务，只需要关心crud的业务即可。



Spring事务是通过代理实现的，当我们通过注解或者声明等方式使用了spring事务后，spring就会为相关的bean生成代理，在crud操作之前和之后完成相关的事务操作。



# 1 隔离级别

## 1.1 数据库的隔离级别

1. Read-Uncommitted
   读未提交，隔离值为0，允许脏读。
2. Read-Committed
   读已提交，隔离值为1，解决了脏读，但是允许不可重复读和幻读。
3. Repeatable-Read
   可重复读，隔离值为2，解决了脏读和不可重复读，但是允许幻读。
4. Serializable
   串行化读，隔离值为3，事务只能一个一个的执行，解决了上述所有问题，但是执行效率慢。



大多数数据库的默认隔离级别为Read-Committed，如SqlServer、Oracle。

少数数据库默认的隔离级别为Repeatable-Read，如Mysql InnoDB。



**概念解释：**

1. 脏读
   事务A修改了数据，但是未提交，这是事务B可以看到A做的修改，如果A回滚，那么B读到的就是脏数据。

2. 不可重复读

   事务A对数据做了两次修改，但是在这两次修改操作之间，事务B对数据进行了修改，那么事务A这两次读取到的数据就是不一致的。

3. 幻读

   事务A对一批数据做修改，此时事务B向这批数据中添加了新数据，那么A就会丢失对B添加的新数据的修改。



## 1.2 Spring的隔离级别

1. ISOLATION_DEFAULT
   Spring默认的隔离级别，使用数据库默认的隔离级别。
2. ISOLATION_READ_UNCOMMITTED
   对应数据库的 Read-Uncommitted 隔离级别。
3. ISOLATION_READ_COMMITTED
   对应数据库的 Read-Committed 隔离级别。
4. ISOLATION_REPEATABLE_READ
   对应数据库的 Repeatable-Read 隔离级别。
5. ISOLATION_SERIALIZABLE
   对应数据库的 Serializable 隔离级别。



# 2 事务传播

Spring中定义了几种不同的事务传播属性，下面通过两个嵌套的方法的代码示例来讲解各个属性



## 2.1 PROPAGATION_REQUIRED

支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。



代码示例:

```
public void A(){

    //如果在B方法执行前,A方法开启了事务,那么B方法使用A的事务
    //如果A方法未开启事务,那么B方法执行开启自己的事务

    B();

}
```



## 2.2 PROPAGATION_REQUIRES_NEW

新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作。



代码示例:

```
public void A(){

    //B方法执行都会开启自己的事务,如果B执行前A开启了事务,那么A的事务将会被挂起
    //当A和B都开启事务时,如果B失败回滚,那么A可以捕获异常,选择是否回滚.
    //当A和B都开启事务时,如果B提交成功,A失败回滚,那么B不会受到影响
    B();

}
```



## 2.3 PROPAGATION_SUPPORTS

支持当前事务，如果当前没有事务，就以非事务方式执行。



代码示例:

```
public void A(){

    //如果A开启了事务,那么B就使用A的事务;如果A未开启事务,那么B也不开启事务
    B();

}
```



## 2.4 PROPAGATION_MANDATORY

支持当前事务，如果当前没有事务，就抛出异常。



代码示例:

```
public void A(){

    //如果A未开启事务,B就抛出异常
    B();

}
```



## 2.5 PROPAGATION_NOT_SUPPORTED

以非事务方式执行操作，如果当前存在事务，就把当前事务挂起



代码示例:

```
public void A(){

    //B总是不开启事务,如果A开启了事务,那么就将A事务挂起
    B();

}
```



## 2.6 PROPAGATION_NEVER

以非事务方式执行，如果当前存在事务，则抛出异常



代码示例:

```
public void A(){

    //B总是不开启事务,如果A开启了事务,那么B就抛出异常
    B();

}
```



## 2.7 PROPAGATION_NESTED

事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。



代码示例:

```
public void A(){

    //A,B,C的事务都是各自独立的
    
    try {
        //如果B失败回滚,可以捕获其异常,然后进行C事务操作
        B();
    }catch (Exception e){
        C();
    }

}
```



# 3 事务配置

## 3.1 编程式事务

### 3.1.1 TransactionTemplate

采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。

如同其他模板，TransactionTemplate是线程安全的。



代码示例:

```
// 新建一个TransactionTemplate
TransactionTemplate tt = new TransactionTemplate(); 
Object result = tt.execute(
        new TransactionCallback(){
            public Object doTransaction(TransactionStatus status){
                updateOperation();
                return resultOfUpdateOperation();
            }
        }); // 执行execute方法进行事务管理
```



### 3.1.2 PlatformTransactionManager

代码示例:

```
//定义一个某个框架平台的TransactionManager，如JDBC、Hibernate
DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
// 设置数据源
dataSourceTransactionManager.setDataSource(this.getJdbcTemplate().getDataSource());
// 定义事务属性
DefaultTransactionDefinition transDef = new DefaultTransactionDefinition();
// 设置传播行为属性
transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED);
// 获得事务状态
TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); 
try {
    // 数据库操作
    dataSourceTransactionManager.commit(status);// 提交
} catch (Exception e) {
    dataSourceTransactionManager.rollback(status);// 回滚
}
```





## 3.2 声明式事务

### 3.2.1 XML方式

```
<!-- 定义事务管理器（声明式的事务） -->
<bean id="transactionManager"
      class="org.springframework.orm.hibernate3.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory" />
</bean>

<!-- 事务配置 -->
<tx:advice id="advice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="update*" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/>
        <tx:method name="insert" propagation="REQUIRED" read-only="false"/>
    </tx:attributes>
</tx:advice>

<!-- 事务切面配置 -->
<aop:config>
    <aop:pointcut id="testService" expression="execution (* com.baobao.service.MyBatisService.*(..))"/>
    <aop:advisor advice-ref="advice" pointcut-ref="testService"/>
</aop:config>
```



### 3.2.2 注解方式

首先开启事务注解的支持（xml与java两种方式，二选一即可）。

**xml config**

```
<!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
</bean>

<!-- 开启事务控制的注解支持 -->
<tx:annotation-driven transaction-manager="transactionManager"/>
```



**java config**

```
 @Bean
 public DataSourceTransactionManager transactionManager(CoeusDynamicDataSource dataSource) throws Exception {
 	return new DataSourceTransactionManager(dataSource);
 }
```



然后使用@Transactional注解（可以通过属性propagation、isolation配置事务传播方式或者隔离级别等参数）。



```
@Transactional	//作用于类上时,该类的所有public方法将都具有该类型的事务属性
public class MyBatisServiceImpl implements MyBatisService {

    @Autowired
    private MyBatisDao dao;


    @Override
    public void insert(Test test) {
        dao.insert(test);
        //抛出unchecked异常，触发事物，回滚  
        throw new RuntimeException("test");
    }
```



```
@Transactional	//也可以直接作用再方法上
public void insert(Test test) {
    dao.insert(test);
}
```