[TOC]



# 1 CountDownLatch

闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。

闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，没有任何线程能通过，当到达结束状态时，这扇门会打开，并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此，这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。

`CountDownLatch`是一种灵活的闭锁实现，它可以是一个或多个线程等待一组事件发生。闭锁状态包含一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。`countDown`方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生，如果计数器的值非零，那么await方法会一直阻塞，直到计数器为零，或者等待中的线程中断，或者等待超时。

`CountDownLatch`也是多线程并发测试中一个非常实用的工具类。



**示例**

```
****** 使用CountDownLatch来实现多线程的计时测试 ******
class TestHarness{
    public long timeTasks(int nThreads,final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for(int i=0;i<nThreads;i++){
            Thread t = new Thread(){
                @Override
                public void run() {
                    try {
                        //此时startGate中计数器为1,每个线程执行前都会等待
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            //线程执行完毕后,递减endGate计数器,说明一个线程的工作已经完成
                            endGate.countDown();
                        }
                    } catch (InterruptedException e) {}
                }
            };
            //线程创建完毕后,开始运行
            t.start();
        }

        //记录开始时间
        long start = System.nanoTime();
        
        //此时所有的线程都创建完毕,等待startGate锁的打开,打开startGate锁,所有线程并发执行
        startGate.countDown();
        
        //计时线程(也就是当前线程)等待所有的线程执行完毕
        endGate.await();
        
        //所有的线程执行完毕后,记录结束时间
        long end = System.nanoTime();
        
        //这样便得到了多个线程并发执行的总时间
        return end-start;
    }
}
```



# 2 FutureTask

`FutureTask`实现了`Future<V>`接口，并实现Runnable接口，因此可以直接run运行，也可以提交给Executor执行。其get方法在Future未启动前会一直阻塞，直到线程启动，并完成计算，返回计算结果或者异常。



**应用场景：通过FutureTask实现连接池**

```
/**
 * 通过FutureTask实现连接池
 */
object ClientChannelPool {

    private val channelPoolMap = ConcurrentHashMap<String, FutureTask<Channel>>()

    fun getChannel(serverAddress: String,serviceName: String): Channel {

        val key = serverAddress + "/" + serviceName

        var channelTask = channelPoolMap[key]

        return if(channelTask != null){
            //future非空,直接get获取连接
            channelTask.get()
        }else{
            //否则创建future
            val newTask = FutureTask<Channel>(Callable {
                Client.newChannel(serverAddress)
            })
            //添加future到map
            channelTask = channelPoolMap.putIfAbsent(key,newTask)
            if(channelTask==null){
                //添加成功,更新channelTask引用,并run建立channel连接
                channelTask = newTask
                channelTask.run()
            }
            //添加不成功,说明其他线程已经添加完毕,那么直接获取
            channelTask.get()
        }

    }

}
```

示例代码使用Kotlin编写，但是整体语法与java相差不大。

如果示例中的`channelPoolMap`使用`ConcurrentHashMap<String, Channel>`结构的话，每次通过key获取channel连接时，如果channel为null，那么就需要创建channel，在并发环境下可能引起重复创建。

想要解决重复创建，可能直接想到使用`synchrozied`同步，如果引入了`synchrozied`，那么某种意义上来说就不能发挥出`ConcurrentHashMap`在并发环境下的最大优势。而通过`FutureTask`，channel连接的创建只发生在成功将`FutureTask`添加到map中时调用run方法，确保了channel连接只创建一次。即使其他线程重复创建了`FutureTask`，因为此时未启动，并不会创建channel，添加失败后不会启动，也就不会引起重复创建。



# 3 Semaphore

Semaphore（信号量）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量，还可以用来实现某种资源池，或者对容器加边界。

Semaphore中管理着一种虚拟的许可，许可的初始数量可通过构造函数来指定。在执行操作时，可以首先获得许可，应该使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可，release方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore，二值信号量可以用作互斥体，并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。

Semaphore中acquire方法在获取不到许可时会等待，但是还有一个tryAcquire方法，当成功获取许可时，此方法返回true，并且Semaphore中许可数-1；当获取失败时，此方法不会等待，直接返回false。在设计一些连接的限定次数的自动重连功能时很好用。



**示例：通过Semaphore给HashSet容器加边界**

```
public class BoundedHashSet<E> {

    private final Set set = new HashSet<E>();

    private final Semaphore semaphore;

    public BoundedHashSet(int size){
        //创建指定大小的信号量
        semaphore = new Semaphore(size);
    }

    public boolean add(E e) throws InterruptedException {
        //每次添加,先从信号量中获取许可
        System.out.println("add : 获取semaphore许可");
        semaphore.acquire();
        System.out.println("add : semaphore许可获取成功,开行进行添加操作");
        boolean success = false;
        try{
            success = set.add(e);
            return success;
        }finally {
            //如果添加失败,那么释放许可
            if(!success){
                semaphore.release();
            }
        }
    }

    public boolean remove(E e){
        boolean success = set.remove(e);
        if(success){
            //如果删除成功,那么释放许可
            semaphore.release();
        }
        return success;
    }

    @Override
    public String toString() {
        return set.toString();
    }

    public static void main(String[] args) throws InterruptedException {

        BoundedHashSet mySet = new BoundedHashSet<String>(5);

        for(int x=1;x<=6;x++){

            System.out.println("---------第"+x+"次add添加---------");
            mySet.add("i am element-"+x);
            System.out.println(mySet);

        }
    }


}

输出结果:
---------第1次add添加---------
add : 获取semaphore许可
add : semaphore许可获取成功,开行进行添加操作
[i am element-1]
---------第2次add添加---------
add : 获取semaphore许可
add : semaphore许可获取成功,开行进行添加操作
[i am element-2, i am element-1]
---------第3次add添加---------
add : 获取semaphore许可
add : semaphore许可获取成功,开行进行添加操作
[i am element-3, i am element-2, i am element-1]
---------第4次add添加---------
add : 获取semaphore许可
add : semaphore许可获取成功,开行进行添加操作
[i am element-3, i am element-2, i am element-4, i am element-1]
---------第5次add添加---------
add : 获取semaphore许可
add : semaphore许可获取成功,开行进行添加操作
[i am element-3, i am element-2, i am element-5, i am element-4, i am element-1]
---------第6次add添加---------
add : 获取semaphore许可
```

可以看到，限定了BoundedHashSet大小为5后，在进行第6次添加时，由于BoundedHashSet内部semaphore许可耗尽，所以只能等待。

Semaphore在实现指定次数的自动重连时也有很大作用。



# 4 AbstractQueuedSynchronizer

推荐阅读这三篇文章：



[AbstractQueuedSynchronizer源码解读](https://www.cnblogs.com/micrari/p/6937995.html)

[深入理解AbstractQueuedSynchronizer（一）](https://www.jianshu.com/p/fadac70b2b1c)

[深入理解AbstractQueuedSynchronizer（二）](https://www.jianshu.com/p/67117db5b426)



写的非常棒，一开始我的想法是先了解一遍AbstractQueuedSynchronizer的大致实现原理，然后尝试通过翻译并注释源码来深度掌握实现原理，但是一番折腾下来，搞得自己也晕了。自认如何也没办法像上面的文章写的那样清晰，所以此处先放上这篇很好的文章。等梳理好思路后会再次尝试写一篇自己的关于AbstractQueuedSynchronizer的源码解读文章。