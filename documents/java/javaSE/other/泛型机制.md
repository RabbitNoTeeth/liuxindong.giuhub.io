[TOC]



# 1  概述

java在1.5版本中引入了泛型，java中的泛型是通过擦除机制实现的，这是为了兼容1.5版本之前的类库。



# 2 何为擦除机制

擦除即在使用泛型时，任何具体的类型信息在运行期间都会被擦除，对泛型中类型的检查只发生在编译阶段。任何泛型类在运行期间都不具有泛型信息。

我们以一个非常简单的示例来演示擦除机制： 

```
public static void main(String[] args) {
    
    List<String> list1 = new ArrayList<>();
    List<Integer> list2 = new ArrayList<>();

    System.out.println(list1.getClass());
    System.out.println(list2.getClass());
    System.out.println(list1.getClass().equals(list2.getClass()));

}

输出结果：
class java.util.ArrayList
class java.util.ArrayList
true
```

在上面的示例代码中，我们创建了两个不同的泛型List集合，如果java中的泛型不是擦除机制，那么list1和list2应该是两个不同的class类型，但是在打印的结果中，可以看到list1和list2编译后不包含任何泛型类型信息，两者编译后的class类型是相同的，都是原生的ArrayList类型。这就是擦除机制的简单演示，任何泛型代码在编译后，是不具有泛型类型信息的。

为什么java选择了擦除机制？如果允许泛型类在运行时携带泛型类型信息，那么在运行时获取泛型信息会相当的方便，但是java是在1.5版本中才添加了泛型的特性，如果允许在运行时携带泛型信息，那么1.5版本之前的类库将与新版本的类库不再兼容，这会带来相当大的代价。 所以，为了向前兼容，java选择了擦除机制。



# 3 擦除的代价

虽然java泛型的擦除机制解决了向前兼容的问题，但是也带来了很明显的问题：泛型不能用于显式地引用运行时类型的操作中，例如转型、instanseof 和new表达式（如 xxx instanseof T 或 new T() 等）。这是因为所有关于参数的类型信息都被擦除了，无论何时，当我们在编写泛型代码时，必须提醒自己，我们只是看起来好像拥有有关参数的类型信息而已。



# 4 何为边界

看完上面的内容，我们会存在一个非常明显得困惑：既然擦除机制在代码运行期间抹除了参数类型信息，那么java是如何保证运行期间泛型类中参数类型的正确性呢？

虽然擦除机制在方法和类内部抹除了参数的类型信息，但是编译器通过边界来保证泛型类和方法内部类型的一致性。 所谓边界，就是对象进入和离开方法的地点。最常见的如getter和setter方法。编译器在边界处进行所有的泛型操作：即对传递进来的值进行类型检查，对传递出去的值进行转型。



# 5 泛型数组

关于泛型数组，有几点要非常注意：

1. 首先，不能直接创建泛型数组，想要创建泛型数组，就要先创建被擦除类型的新数组，然后对其转型。
2. 对于在泛型中创建数组，推荐使用Array.newInstance()，然后将其转型。
3. 多数情况下，如果需要使用泛型数组，可以考虑使用泛型ArrayList来代替。 