[TOC]



# 1 继承

在包的内部使用继承是非常安全的，但是，对于普通的具体类，进行跨越包边界的继承，则是非常危险的。
继承打破了封装性，超类的实现可能随着发行版本的不同而变化，如果真的发生了变化，那么子类可能会遭到破坏。



我们先来看一个错误使用继承的示例：

```
public class MyHashSet<E> extends HashSet<E> {
    
    private int addCount;

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```

上述代码示例中，MyHashSet继承了HashSet，覆写了add和addAll方法，加入自己的一个计数功能逻辑。但我们调用addAll方法来传入一个含有3个元素的集合时，我们期望调用getAddCount()方法的返回值为3，但是实际返回值为6。这是为什么呢？原因是HashSet中，addAll方法的实现是对add方法的循环调用，所以addCount会变为6。

上述示例简单的说明了，继承带来的某种风险，那就是当子类方法依赖父类的方法时，如果父类方法发生了变化，或者对于父类方法的调用不正确，不了解父类方法的实现逻辑，那么就会引起子类无法正常工作。



# 2 复合

幸运的是，有一种方法可以避免上面提到的继承带来的种种风险。不需要扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为”复合”。

使用复合来修正上述代码示例：

```
public class MyHashSet<E>  {
    
    private final Set<E> set = new HashSet<>();

    private int addCount;

    public boolean add(E e) {
        addCount++;
        return set.add(e);
    }

    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return set.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```

MyHashSet中add和addAll方法的调用都转发给了内部HashSet，这样的方法被称为转发方法。MyHashSet也可以称为包装类。

注意：包装类不适合用在回调框架中，因为在回调框架中，对象通过this把自身的引用传递给其他对象，用于后续的调用。如果是在包装类中，this传递便是包装类，而不是所需要的对象本身。



# 小结

只有当子类和超类之间存在子类型关系时，才应该使用继承。否则，优先考虑包装类，因为包装类不仅比子类更加健壮，而且功能也更加强大。