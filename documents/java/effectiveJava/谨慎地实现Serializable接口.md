[TOC]

对于序列化，大多数人可能存在一种误解：认为在java中可以很简单的实现序列化，只需要 implements Serializable即可。但是实际情况却并没有我们想象的那样简单。

在设计一个要实现序列化的类时，我们必须明确实现序列话会带来哪些影响，以及是否能接受这些影响，并且如何将这些影响带来的负面效果降低到最小。

# 1 实现Serializable的代价

1. 降低了”改变这个类的实现”的灵活性。

   如果接受了默认的序列化形式，这个类中所有的私有的和包级私有的实例域都将成为导出API的一部分，从而违背了将它们设计为私有化的初衷。
   序列化也会使类的演变受到限制。每个可序列化的类都有一个唯一的标识号与它相关联。如果你没有在一个名为serialVersionUID的私有静态final的long域中显式地指定该标识号，系统就会自动根据该类来进行一个复杂的计算，产生一个标识号。如果你没有显式地声明一个标识号，当类在后期增加字段或者方法时，系统自动生成的标识号与之前的不一致，将会引起兼容性问题。



2. 增加了出现bug和安全漏洞的可能性。

   无论你是接受了默认的序列化行为，还是自定义了序列化行为，反序列化机制都是一个”隐藏的构造器”，具备与其他构造器相同的特点。如果你的类在构造函数中需要初始化各个实例域的某些约束关系，当反序列化时，如果不能在readObject方法中进行这些约束的初始化，那么反序列化创建的类就不具有该有的约束，这也就造成了潜在的安全问题。



# 2 实现Serializable接口的一些建议:

1. 为了继承而设计的类应该尽可能少地去实现Serializable接口，用户的接口也应该尽可能少地实现Serializable接口。

2. 如果你实现了一个带有实例域的类，它是可序列化和可扩展的，如果类有一些约束条件，当类的实例域被初始化成它们的默认值时，就会违背这些约束条件，这时你就必须为这个类添加一个readObjectNoData方法: 

```
private void readObjectNoData() throws InvalidObjectException{
    throw new InvalidObjectException("Stream data required");
}
```

3. 如果一个专门为了继承而设计的类不是可序列化的，就不可能编写出可序列化的子类。如果想要子类实现可序列化，考虑提供一个无参构造函数。

4. 内部类不应该实现Serializable，静态成员类可以实现Serializable。