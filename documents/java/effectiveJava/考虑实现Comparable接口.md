[TOC]

Java平台类库的所有值类都实现了Comparable接口，如果你正在编写一个值类，它具有非常明显的内在排序关系，比如按照字母顺序、数值顺序或者年代顺序，那你就应该坚决考虑实现该接口。

# 1 通用约定

在下面的说明中用sgn来表示compareTo的结果：负值、0、正值。compareTo方法的约定和equals相似：

1. 确保所有的x和y都满足 sgn(x.compareTo(y) = -sgn(y.compareTo(x))) 。

   这也意味着,当两者中任意一个抛出异常时,另一个也必须抛出异常 。

2. 确保传递性。

   对所有的x、y和z，满足 ( x.compareTo(y) > 0 && y.compareTo(z) > 0 ) = true 时，x.compareTo(z) > 0 。

3. 确保 x.compareTo(y) == 0时，满足对于所有的z，sgn(x.compareTo(z)) == sgn(y.compareTo(z)) 。

4. 不要在compareTo方法中对不同类型的对象进行比较。
5. 强烈建议满足 ((x.compareTo(y) ==0) == x.equals(y))，这个约定并不是必须满足的，但是建议实现。如果一个实现了Comparable接口的类不满足该条件，那么应该给予明确的说明，如：“注意，该类具有内在的排序功能，但是与equals不一致”。

违反了compareTo约定的类会破坏其他依赖比较关系的类，如TreeSet、TreeMap、以及工具类Collections和Arrays等。



# 2 优化建议

1. 如果你想为一个实现了Comparable接口的类增加值组件，请不要扩展这个类，而是要编写一个不相关的类，其中包含第一个类的实例，然后提供一个”视图”方法返回这个实例。这样既可以让你自由地在第二个类上实现compareTo方法，同时也允许它的客户端在必要的时候，把第二个类的实例视同第一个类的实例。

2. CompareTo方法中域的比较是顺序的比较而不是等同性的比较。比较对象引用域也可以是通过递归地调用compareTo方法来实现，如果一个域并没有实现Comparable接口，或者你需要使用一个非标准的排序关系，就可以使用一个显示的Comparator来代替。或者编写自己的Comparator，或者使用已有的Comparator。 

3. 如果一个类有多个关键域，那么按什么样的顺序来比较这些域是非常关键的，你必须从最关键的域开始，逐步进行到所有的重要域，如果某个域的比较产生了非零的结果，则整个比较操作结束，并返回该结果，如果最关键的域是相等的，要进一步比较次关键的域，如果所有的域都是相等的，则对象就是相等的，并返回零。