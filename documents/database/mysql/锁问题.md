[TOC]



# 1 MyISAM表锁

## 1.1 锁模式

MyISAM表锁分为两种模式：

1. 表共享读锁

   当一个线程获取了读锁时，不会阻塞其他线程的读操作，但是会阻塞其他线程的写操作。

2. 表独占写锁

   当一个线程获取了写锁时，其他线程的读写操作都会被阻塞，直到锁被释放。



## 1.2 锁策略

MyISAM在执行 select 语句前，会自动给涉及的表加上读锁；在执行 insert、update、delete 等更新语句时，自动给涉及的表加写锁。这些操作不需要用户显式地通过lock tables来加锁，MySQL自动完成。

当需要显式地通过lock tables语句，来更新多个表时，必须同时获取所有涉及的表的锁。因为在lock tables获取到表锁后，只能访问加锁的表，这也是MyISAM表不会出现死锁的原因，因为每次执行sql语句，MyISAM总是自动获取所有需要的锁。



## 1.3 并发插入

MyISAM存储引擎有一个系统变量 concurrent_insert，专门用于控制并发插入的行为，可选值有0、1或2：

1. concurrent_insert = 0

   不允许并发插入。

2. concurrent_insert = 1

   如果表中没有空洞（即表的中间没有被删除的行），在一个线程读表的同时，允许另一个线程在表尾并发插入，这也是默认设置。

3. concurrent_insert = 2

   无论表中有没有空洞，都允许在表尾并发插入。



## 1.4 锁调度

当线程a请求获取读锁，线程b同时请求获取写锁时，总是b先获取到写锁。即便是线程a先到锁等待队列，b后到，也是b先获取到写锁。因为MyISAM认为写请求一般比读请求重要。这也是为什么MyISAM不适合有大量更新操作和查询操作的原因，因为当锁竞争激烈时，可能导致读线程很难获取到锁，甚至可能永远阻塞，从而降低应用的性能。



# 2 InnoDB行锁

## 2.1 加锁策略

在不通过索引条件查询时，InnoDB会锁定表中的所有记录。

InnoDB行锁是针对索引加锁，不是针对记录加锁，所以当访问不同行的数据，但是使用了相同的索引键，是会出现锁冲突的。

当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不论是使用主键索引、唯一索引还是普通索引。



## 2.2 死锁

InnoDB表是会出现死锁的，如线程a和b使用相同的索引键，获取对方的数据时，就会引发死锁。

要避免死锁，最好在应用逻辑处理阶段定义好不同表的关联关系以及访问顺序，从根本上避免死锁；或者以牺牲部分性能为代价，在进行复杂sql操作时，申请到足够级别的锁。 