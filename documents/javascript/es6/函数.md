[TOC]



# 1 默认参数值

声明函数时，可以为任意参数指定默认值，在已指定默认值的参数后可以继续声明无默认值参数。

```
function sayHi(name,age = 26){
    console.log(`hi, i am ${name}, ${age} years old`);
}
sayHi("jack");
sayHi("rose",18);
输出结果：
hi, i am jack, 26 years old
hi, i am rose, 18 years old
```



**默认参数值对arguments对象的影响：**

在ES6中，如果一个函数使用了默认参数值，那么无论是否显式定义了严格模式，arguments对象都会与命名参数保持分离，即参数值在方法体内的修改不会影响arguments对象，arguments对象中保存的永远是参数的初始值。

```
function sayHi(name,age = 26){
    console.log(arguments[0]);
    console.log(arguments[1]);
    name='tom';
    age = 15;
    console.log(arguments[0]);
    console.log(arguments[1]);
}

sayHi("jack");
console.log('------------');
sayHi("rose",18);

输出结果：
jack
undefined
jack
undefined
------------
rose
18
rose
18
```



# 2 默认参数表达式

```
function getName(){
    return "liuxindong";
}

function sayHi(name = getName()){
    console.log(name);
}

sayHi();
sayHi("jack");
输出结果：
liuxindong
jack
```


注意，当使用函数调用结果作为默认参数时，如果忘记写小括号，例如，name = getName，则最终传入的是对函数的引用，而不是函数调用的结果。

默认参数是在函数调用时求值，所以可以使用先定义的参数作为后定义参数的默认值，例如：

```
function add(first, second = first){
    console.log( first + second )
}

add(1);
输出结果：
2
```


在引用参数默认值的时候，只允许引用前面参数的值，即先定义的参数不能访问后定义的参数。

函数参数有自己的作用域和临时死区，其与函数体的作用域是各自独立的，也就是说参数的默认值不可访问函数体内声明的变量。



# 3 不定参数

在函数的命名参数前面加三个点(...)就表明这是一个不定参数，该参数是一个数组

```
function getName(...names){
    for(name of names){
        console.log(name)
    }
}

getName('tom','jerry','jack','rose');
输出结果：
tom
jerry
jack
rose
```



**不定参数的使用限制：**

首先，每个函数最多只能声明一个不定参数，并且一定要放在所有参数的末尾。
其次，不定参数不能用于对象字面量setter中（这是因为对象字面量setter的参数有且只能有一个），如：

```
let person = {
    set names(...values){
        //...
    }
};
```



**不定参数对arguments对象的影响：**

如果声明函数时定义了不定参数，则在函数被调用时，arguments对象包含了所有传入函数的参数。

```
function getArgs(...args){
    console.log(args.length);
    console.log(arguments.length);
    console.log(args[0],args[1]);
    console.log(arguments[0],arguments[1]);
}

getArgs('a','b');
输出结果：
2
2
a b
a b
```



无论是否使用不定参数，arguments对象总是包含所有传入函数的参数。



# 4 展开运算符

展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数。

```
let nums = [1,2];

function sum(a, b) {
    console.log(a + b)
}

sum(...nums);
输出结果：
3
```



# 5 name属性

ES6中所有的函数的name属性都有一个合适的值

```
function aaa() {
    //...
}

let bbb = function () {
    //...
};

console.log(aaa.name);
console.log(bbb.name);
输出结果：
aaa
bbb
```

通过上面的示例可以看到，普通函数的name属性值为声明函数时的名称，而匿名函数的name属性值为被赋值为该匿名函数的变量的名称。



**name属性的特殊情况：**

代码示例1：

```
let aaa = function bbb() {
    //...
};

let person = {
    get firstName() {
        return 'don9'
    },
    sayName: function () {
        //...
    }
};

console.log(aaa.name);
console.log(person.firstName.name);
console.log(person.sayName.name);
输出结果：
bbb
undefined
sayName
```



代码示例2：
通过`bind()`函数创建的函数，其名称将带有”bound”前缀，通过Function构造函数创建的函数，其名称是”anonymous”。

```
let aaa = function () {
    //...
};

console.log(aaa.bind().name);
console.log(new Function().name);
输出结果：
bound aaa
anonymous
```



切记，函数name属性的值不一定引用同名变量，它只是协助调试用的额外信息，所以不能使用name属性的值来获取对于函数的引用。



# 6 元属性new.target

为了解决判断函数是否是通过new关键字调用的问题，ES6引入了`new.target`这个元属性。 

当调用函数的构造方法时，`new.target`被赋值为new操作符的目标，通常是新创建的对象实例，也就是函数体内this的构造函数；如果调用call方法，则`new.target`的值为undefined。

可以通过检查`new.target`是否被定义来安全地检测一个函数是否是通过new关键字调用的。



示例：

```
function Person(name){
    if(typeof new.target !== 'undefined'){
        console.log(name);
    }else{
        throw new Error("必须通过new关键字来调用")
    }
}

let person = new Person('jack');
let aaa = Person.call(person,"rose");
输出结果：
jack
Error: 必须通过new关键字来调用
```



注意：在函数外使用 `new.target` 是一个语法错误。



# 7 块级函数

在ES6中，在定义函数的代码块内，块级函数会被提升到顶部，因此在函数定义的任何位置调用它，总是能返回正确结果。

```
function aaa() {
    bbb();
    function bbb() {
        console.log('i am bbb')
    }
}

aaa();

输出结果：
i am bbb
```



块级函数会被提升至函数顶部，但是let声明的却不会。如果需要函数提升至顶部，则使用块级函数，否则使用let表达式，如下：

```
function aaa() {
    bbb();
    let bbb = function () {
        console.log('i am bbb')
    }
}

aaa();

输出结果：
ReferenceError: bbb is not defined
```



# 8 箭头函数

## 8.1 特性

1. 没有this、super、arguments和 new.target 绑定。
2. 不能通过new关键字调用。
3. 没有原型。
4. 不可以改变this的绑定。
5. 不支持arguments对象。
6. 不支持重复的命名参数。



## 8.2 语法

```
//------示例一
let aaa1 = function () {
    console.log('i am aaa1')
};

let aaa2 = () => console.log('i am aaa2');

//------示例二
let bbb1 = function () {
    return 'liuxindong'
};

let bbb2 = () => 'liuxindong';

//------示例三
let ccc1 = function (age) {
    return 'liuxindong-' + age
};

let ccc2 = age => 'liuxindong-' + age;

//------示例四
let ddd1 = function (a,b) {
  return a + b;  
};

let ddd2 = (a,b) => a + b;

通过箭头函数创建一个立即执行的函数：
let person = ((name) => console.log('i am ' + name))("liuxindong");
输出结果：
i am liuxindong
```



箭头函数缺少正常函数所拥有的prototype属性，它的设计初衷是“即用即弃”，所以不能用它来定义新的类型。如果尝试通过new关键字调用一个箭头函数，会导致程序抛出错误。

箭头函数中的this值取决于该函数外部非箭头函数的this值，且不能通过call()、apply()或者bind()方法来改变this的值。

箭头函数语法简单，非常适合作为回调函数。