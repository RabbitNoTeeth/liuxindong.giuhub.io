[TOC]



# 1 新增API

## 1.1 静态方法

### 1.1.1 Array.of()

创建一个包含所有参数的数组：

```
let arr = Array.of(1,2,3);

console.log(arr);

输出结果：
[ 1, 2, 3 ]
```



### 1.1.2 Array.from()


接受可迭代对象或类数组对象作为第一个参数，最终返回一个数组：

```
let set = new Set();
set.add(1);
set.add(2);
set.add(3);

let arr = Array.from(set);
console.log(arr);

输出结果：
[ 1, 2, 3 ]
```



如果想要进一步转换数组，可以提供一个映射函数作为第二个参数：

```
let set = new Set();
set.add(1);
set.add(2);
set.add(3);

let arr = Array.from(set, item => item + 2);
console.log(arr);

输出结果：
[ 3, 4, 5 ]
```



## 1.2 成员方法

### 1.2.1 find()、findIndex()


这两个方法都接受两个参数：一个是回调函数，另一个是可选参数，用于指定回调函数中this的值。 执行回调函数时，传入的参数为：数组的某个元素、该元素的索引、数组本身，一旦回调函数返回true，那么立即停止，find()方法返回当前的元素，而findIndex()返回当前元素的索引。

```
let arr = [1,2,3,4,5];

console.log(arr.find(item => item > 3));
console.log(arr.findIndex(item => item > 3));

输出结果：
4
3
```



### 1.2.2 fill()


用指定的值填充一至多个数组元素，当传入一个值时，fill()方法会用这个值重写数组中的所有值：

```
let arr = [1,2,3,4,5];
arr.fill(9);
console.log(arr);

输出结果：
[ 9, 9, 9, 9, 9 ]
```



如果只想改变数组的某一部分，可以传入开始索引和结束索引分别作为第2和第3个参数：

```
let arr = [1,2,3,4,5];
arr.fill(9,0,2);
console.log(arr);

输出结果：
[ 9, 9, 3, 4, 5 ]
```



如果开始索引或者结束索引为负值，那么这些值会与length属性相加来作为最终位置：

```
let arr = [1,2,3,4,5];
arr.fill(9,-3,-1);
console.log(arr);

输出结果：
[ 1, 2, 9, 9, 5 ]
```



### 1.2.3 copyWithin()


从数组中复制元素的值。需要传入两个参数：参数1为开始填充值的索引位置，参数2为开始复制值的索引位置：

```
let arr = [1,2,3,4,5];
arr.copyWithin(2,0);
console.log(arr);

输出结果：
[ 1, 2, 1, 2, 3 ]
```



还可以传入第3个可选参数，作为结束复制值的位置：

```
let arr = [1,2,3,4,5];
arr.copyWithin(2,0,1);
console.log(arr);

输出结果：
[ 1, 2, 1, 4, 5 ]
```

和`fill()`方法一样，`copyWithin()`方法的所有参数都接受负值，并且会自动与数组长度相加来作为最终使用的索引。



# 2 定型数组


所谓定型数组，就是将任何数字转换为一个包含数字比特的数组，然后就可以通过数组方法来进一步处理。

定型数组支持存储和操作8种不同的数值类型：

1. 有符号的8位整数
2. 无符号的8位整数
3. 有符号的16位整数
4. 无符号的16位整数
5. 有符号的32位整数
6. 无符号的32位整数
7. 32位浮点数
8. 64位浮点数



## 2.1 数组缓冲区


数组缓冲区是所有定型数组的根基，它是一段可以包含特定数量字节的内存地址，可以通过构造函数创建，并指定缓冲区大小：

```
let buffer = new ArrayBuffer(10);
console.log(buffer.byteLength);

输出结果：
10
```

数组缓冲区的大小在创建时就已经确定，可以修改缓冲区内的数据，但是不可以修改缓冲区的大小。



### 2.1.1 通过视图操作数组缓冲区


数组缓冲区是内存中的一段地址，视图是用来操作内存的接口。DataView类型是一种通用的数组缓冲区视图，支持所有8种数值型数据类型：

```
let buffer = new ArrayBuffer(10);

let view1 = new DataView(buffer),
    view2 = new DataView(buffer,5,2);

console.log(view1.buffer === buffer);
console.log(view2.buffer === buffer);
console.log(view1.byteOffset);
console.log(view2.byteOffset);
console.log(view1.byteLength);
console.log(view2.byteLength);

输出结果：
true
true
0
5
10
2
```



### 2.1.2 读取和写入数据


所有的8种数据类型，都能在DataView的原型上找到相关的set和get方法，视图是独立的，无论数据之前是以何种方式存储的，都可以在任意时刻读取或写入任意格式的数据：

```
let buffer = new ArrayBuffer(2),
    view = new DataView(buffer);

view.setInt8(0,5);
view.setInt8(1,-1);

console.log(view.getInt16(0));
console.log(view.getInt8(0));
console.log(view.getInt8(1));

输出结果：
1535
5
-1
```

当混合使用不同数据类型时，DataView是完美的选择，如果只使用某个特定类型的数据，那么特定类型的视图是更好的选择。

ES6为每种数据类型都提供了对应的视图(定型数组)：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array、Float64Array。其中，Uint8ClampedArray与Uint8Array大致相同，唯一的区别在于当数组缓冲区的值小于0或者大于255时，Uint8ClampedArray会分别将其转换为0或255。



## 2.2 创建定型数组

```
let buffer = new ArrayBuffer(10);

// 通过数组缓冲区创建
let view1 = new Int8Array(buffer);

// 通过数组缓冲区创建，指定比特偏移量和长度值
let view2 = new Int8Array(buffer,5,2);

// 通过数字创建，该数字表示分配给数组的元素数量，而不是字节数量
let view3 = new Int16Array(5);
console.log(view3.byteLength);      // 10
console.log(view3.length);          // 5

// 通过传入对象创建，该对象可以是：一个定型数组、一个可迭代对象、一个数组或者一个类数组对象
let view4 = new Int8Array([1,2,3]);
```

调用定型数组的构造函数时如果不传参数，会按照传入0来处理，这样由于缓冲区没有分配到任何比特，因而创建的定型数组不能用来保存数据。



## 2.3 与普通数组的差别

### 2.3.1 行为差别


定性数组不是数组，它不继承自Array，无法通过`Array.isArray()`来检查定型数组：

```
let arr = new Int8Array([1,2]);

console.log(Array.isArray(arr));

输出结果：
false
```



当操作普通数组时，其可以变大变小，但定型数组却始终保持相同的大小。给定型数组中不存在的数值索引赋值会被忽略，而在普通数组中就可以：

```
let arr1 = [1,2];
let arr2 = new Int8Array([1,2]);

console.log(arr1.length);
console.log(arr1[2]);
console.log(arr2.length);
console.log(arr2[2]);

console.log('-----------');

arr1[2] = 3;
arr2[2] = 3;

console.log(arr1.length);
console.log(arr1[2]);
console.log(arr2.length);
console.log(arr2[2]);

输出结果：
2
undefined
2
undefined
-----------
3
3
2
undefined
```



定型数组检查数据类型的合法性，0被用于代替所有的非法值：

```
let arr = new Int8Array([1]);
arr[0] = 'aaa';
console.log(arr[0]);

输出结果：
0
```



### 2.3.2 缺失的方法

定型数组包含许多与普通数组相同的方法，但是同时也缺失了以下几个方法：`concat()`、`shift()`、`pop()`、`splice()`、`push()`、`unshift()`。



### 2.3.3 附加方法


定型数组中有两个普通方法中没有的方法：`set()`和`subarray()`

`set()`方法将其他数组复制到已有的定型数组：

```
let arr = new Int8Array(4);
arr.set([25,50]);
arr.set([75,100],2);    //可以传入开始插入数据的位置
console.log(arr);

输出结果：
Int8Array [ 25, 50, 75, 100 ]
```



`subarray()`方法提取已有定型数组的一部分作为一个新的定型数组，可以传入可选的起始位置和结束位置：

```
let arr = new Int8Array([1,2,3,4]);
console.log(arr.subarray());
console.log(arr.subarray(2));
console.log(arr.subarray(1,3));

输出结果：
Int8Array [ 1, 2, 3, 4 ]
Int8Array [ 3, 4 ]
Int8Array [ 2, 3 ]
```