[TOC]



# 1 类声明

```
class PersonClass{
	
    constructor(name){        //构造函数
        this.name = name;
    }

    sayName(){                 //成员方法
        console.log(this.name)
    }

}

let person = new PersonClass('liuxindong');

person.sayName();

console.log(person instanceof PersonClass);
console.log(typeof person);
console.log(typeof PersonClass);

输出结果：
liuxindong
true
object
function
```

从最后一行的输出可以看出，ES6中的类声明本质上是一个语法糖，通过类定义语法定义的类，本质上还是function。 不过与函数不同的是，类属性是只读的，不可被赋予新值。



# 2 命名类表达式

```
let PersonClass = class PersonClass2{

    constructor(name){
        this.name = name;
    }

    sayName(){
        console.log(this.name)
    }

};

console.log(typeof PersonClass);
console.log(typeof PersonClass2);
输出结果：
function
undefined
```



# 3 作为一等公民的类

在程序中，一等公民是指一个可以传入函数，可以从函数返回，并且可以赋值给变量的值。 ES6中将类也设计为一等公民。

```
function createObject(classDef) {
    return new classDef();
}

let obj = createObject(class {
    sayHi(){
        console.log('hi!');
    }
});

obj.sayHi();

输出结果：
hi!
```



类表达式还有另一种使用方式，通过立即调用类构造函数可以创建单例。用new调用类表达式，紧接着通过一对小括号调用这个表达式。

```
let person = new class{

    constructor(name){
        this.name = name;
    }

    sayName(){
        console.log(this.name);
    }

}('liuxindong');

person.sayName();

输出结果：
liuxindong
```



# 4 访问器属性 

类支持直接在原型上定义访问器属性。getter对应的关键字为get，setter对应的关键字为set，如下示例：

```
class PersonClass{

    constructor(name){
        this.myName = name;
    }

    get name(){
        console.log('getter invoke!');
        return this.myName;
    }

    set name(name){
        console.log('setter invoke!');
        this.myName = name;
    }

}

let person = new PersonClass('jack');

console.log(person.name);
person.name = 'rose';
console.log(person.name);

输出结果：
getter invoke!
jack
setter invoke!
getter invoke!
rose
```



# 5 可计算成员名称

类方法和访问器属性也支持使用可计算名称

```
let methodName = 'sayName';
let propertyName = 'name';

class PersonClass{

    constructor(name){
        this.myName = name;
    }

    get [propertyName](){
        console.log('getter invoke!')
        return this.myName;
    }

    set [propertyName](name){
        console.log('setter invoke!')
        this.myName = name;
    }

    [methodName](){
        console.log(this.myName);
    }

}

let person = new PersonClass('jack');

person.sayName();
person.name = 'rose';
console.log(person.name);

输出结果：
jack
setter invoke!
getter invoke!
rose
```



# 6 生成器方法

在类中可以将任何方法定义成生成器。

```
class MyClass{

    *createIterator(){
        yield 1;
        yield 2;
        yield 3;
    }

}

let obj = new MyClass();
let iterator = obj.createIterator();

console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());

输出结果：
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
```



可以通过`Symbol.iterator`为类定义默认迭代器：

```
class MyClass{

    constructor(){
        this.items = [];
    }

    *[Symbol.iterator](){
        yield *this.items;
    }

}

let obj = new MyClass();
obj.items.push(1);
obj.items.push(2);
obj.items.push(3);

for(let item of obj){
    console.log(item)
}

输出结果：
1
2
3
```



# 7 静态成员

ES6的类语法简化了创建静态成员的过程，在方法或者访问器属性名前使用static关键字即可，需要注意的是，不可以在实例中访问静态成员，必须要直接在类中访问静态成员：

```
class MyClass{

    static sayHi(){
        console.log('i am a static function!')
    }

}


MyClass.sayHi();

let obj = new MyClass();
obj.sayHi();

输出结果：
i am a static function!
TypeError: obj.sayHi is not a function
```



# 8 继承与派生类

ES6中，类通过extends关键字实现继承，继承自其他类的类被称为派生类，通俗理解就是子类。 如果子类中指定了构造函数，那么必须在构造函数中调用super()；子类中的方法总会覆盖父类中的同名方法；如果父类有静态成员，那么这些静态成员在子类中也可用。

```
class Person{

    constructor(){
        console.log('Person constructor invoke!')
    }

    static sayHi(){
        console.log('Person static function invoke!')
    }

    sayName(){
        console.log('Person sayName invoke!')
    }

}

class Man extends Person{

    constructor(){
        super()
        console.log('Man constructor invoke!')
    }

    sayName(){
        console.log('Man sayName invoke!')
    }

}

let obj = new Man();
Man.sayHi();
console.log(obj instanceof Person);
obj.sayName();

输出结果：
Person constructor invoke!
Man constructor invoke!
Person static function invoke!
true
Man sayName invoke!
```



# 9 派生自表达式的类

只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生

```
function Person(name,age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHi = function () {
    console.log(`hi! i am ${this.name} , ${this.age}`)
};

function getPerson(){
    return Person;
}

class Me extends getPerson(){
    constructor(name,age) {
        super(name, age)
    }
}

let p = new Me('liuxindong',26);
p.sayHi();
console.log(p instanceof Person);

输出结果：
hi! i am liuxindong , 26
true
```



可以根据该特性来实现mixin：

```
let AAA = {
    aaa(){
        console.log('i am function aaa!')
    }
};

let BBB = {
    bbb(){
        console.log('i am function bbb!')
    }
};

function minxin(...mixins) {
    let base = function () {};
    Object.assign(base.prototype, ...mixins);
    return base;
}

class CCC extends minxin(AAA, BBB){

}

let ccc = new CCC();
ccc.aaa();
ccc.bbb();

输出结果：
i am function aaa!
i am function bbb!
```

如果多个mixin对象具有相同属性，那么只有最后一个被添加的属性被保留。



# 10 内建对象的继承

ES6支持内建对象继承。

在ES5的传统继承方式中，先由派生类型(MyArray)创建this的值，然后调用基类(Array)的构造函数。这就意味着，this的值开始指向的是MyArray的实例，但是随后会被来自Array的其他属性所修饰。

ES6中的类继承与之相反，先由基类(Array)创建this的值，然后派生类的构造函数再修改这个值。这样就能保证可以通过this访问基类的所有内建功能。



# 11 new.target

在类的构造函数中，可以通过`new.target`来确定类是如何被调用的：

```
class AAA{
    constructor(){
        if(new.target === AAA){
            throw new Error('类AAA不能被实例化！')
        }
    }
}

class BBB extends AAA{
    constructor(){
        super();
        console.log('实例化BBB')
    }
}

let bbb = new BBB();
let aaa = new AAA();

输出结果：
实例化BBB
Error: 类AAA不能被实例化！
```

因为类必须通过new关键字才能调用，所以在类的构造函数中，`new.target`属性永远不会是undefined。

