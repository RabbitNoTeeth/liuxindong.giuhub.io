[TOC]



# 1 什么是生成器

生成器是一种返回迭代器的函数，通过`function`关键字后的星号（*）来表示，函数中会用到新的关键字`yield`。

```
function *createIterator(){
    yield 1;
    yield 2;
    yield 3;
}

let iterator = createIterator();
console.log(iterator.next().value);
console.log(iterator.next().value);
console.log(iterator.next().value);
输出结果：
1
2
3
```



`yield`关键字也是ES6的新特性，可以通过它来指定调用迭代器的`next()`方法时的返回值及返回顺序。使用`yield`关键字可以返回任何值或者表达式。

```
function *createIterator(items){
    for(let i in items){
        yield items[i];
    }
}

let iterator = createIterator([1,2,3]);
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
输出结果：
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
```



yield关键之只能在生成器内部使用，在其他地方使用会导致程序抛出错误，即便是生成器内部的函数中也不行：

```
function *createIterator(items){
    items.forEach(item => {
        //语法错误！
        yield item;
    })
}
```



# 2 生成器函数表达式

也可以通过函数表达式来创建生成器，只需在function关键字和小括号间添加一个星号（*）即可：

```
let createIterator = function *(items){
    for(let i in items){
        yield items[i];
    }
};

let iterator = createIterator([1,2,3]);
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
输出结果：
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
```



# 3 生成器对象的方法 

由于生成器本身就是函数，因而可以将它们添加到对象中。可以使用ES6的函数方法的简写方式来创建生成器：

```
let p = {
    *createIterator(items){
        for(let i in items){
            yield items[i];
        }
    }
};

let iterator = p.createIterator([1,2,3]);
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
输出结果：
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: undefined, done: true }
```



# 4 可迭代对象和for-of循环 

可迭代对象具有`Symbol.iterator`属性，是一种与迭代器密切相关的对象。 由于生成器默认会为`Symbol.iterator`属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象。

ES中新加入了for-of循环，来简化可迭代对象的遍历过程。for-of循环每执行一次都会调用可迭代对象的`next()`方法，并将迭代器返回结果对象的value属性的值存储在一个变量中，循环将在done属性值为true时终止：

```
let arr = [1,2,3,4];

for(let item of arr){
    console.log(item);
}
输出结果：
1
2
3
4
```



如果将for-of循环用于不可迭代对象、null或undefined将会导致程序抛出错误。



# 5 访问默认迭代器 

具有`Symbol.iterator`属性的对象都有默认的迭代器，因此可以用来检测对象是否为可迭代对象：

```
function isIterable(obj) {
    return typeof obj[Symbol.iterator] === 'function';
}

console.log(isIterable([1,2,3]));
console.log(isIterable('hello'));
console.log(isIterable(new Map()));
console.log(isIterable(new Set()));
console.log(isIterable(new WeakMap()));
console.log(isIterable(new WeakSet()));
输出结果：
true
true
true
true
false
false
```



# 6 创建可迭代对象 


默认情况下，开发者定义的对象都是不可迭代的对象，但如果给`Symbol.iterator`属性添加一个生成器，则可以将其变为可迭代对象：

```
let myCollection = {
  items: [],
  *[Symbol.iterator](){
      for (let item of this.items){
          yield item;
      }
  }
};

myCollection.items.push(1);
myCollection.items.push(2);
myCollection.items.push(3);

for(let item of myCollection){
    console.log(item)
}
输出结果：
1
2
3
```



# 7 内建迭代器 

在ES6中有3种类型的集合对象：数组、Map和Set，这三种对象都内建了以下3种迭代器。



## 7.1 entries()

返回一个含有两个元素的数组：当遍历对象是数组时，第一个元素为索引，第二个元素为对应的值；Set时，两个元素相同，都是值；Map时，第一个元素为键，第二个为值

```
let arr = [1,2,3];
let set = new Set([4,5,6]);
let map = new Map([['k7',7],['k8',8],['k9',9]]);

for(let item of arr.entries()){
    console.log(item)
}
for(let item of set.entries()){
    console.log(item)
}
for(let item of map.entries()){
    console.log(item)
}
输出结果:
[ 0, 1 ]
[ 1, 2 ]
[ 2, 3 ]
[ 4, 4 ]
[ 5, 5 ]
[ 6, 6 ]
[ 'k7', 7 ]
[ 'k8', 8 ]
[ 'k9', 9 ]
```



## 7.2 values() 

返回集合中存储的所有值。



## 7.3 keys()

返回集合中的所有键：如果是数组，则返回的是索引；Set时，返回的是值；Map时，返回的是所有的键。

数组和Set集合的默认迭代器是value()方法，Map的默认迭代器是entries()方法。

在for-of循环中，可以使用解构语法：

```
let map = new Map([['k7',7],['k8',8],['k9',9]]);

for(let [key,value] of map.entries()){
    console.log(key + "=" + value)
}
输出结果：
k7=7
k8=8
k9=9
```



# 8 展开运算符与非数组可迭代对象

展开运算符可作用于任意可迭代对象，如果想要将可迭代对象转换为数组，那么展开运算符是最简单的方法。

```
let set = new Set([1,2,3]);
let map = new Map([['k7',7],['k8',8],['k9',9]]);

let arr1 = [...set];
let arr2 = [...map];
let arr3 = [4,5,6,...set,...map];

console.log(arr1);
console.log(arr2);
console.log(arr3);
输出结果：
[ 1, 2, 3 ]
[ [ 'k7', 7 ], [ 'k8', 8 ], [ 'k9', 9 ] ]
[ 4, 5, 6, 1, 2, 3, [ 'k7', 7 ], [ 'k8', 8 ], [ 'k9', 9 ] ]
```



# 9 给迭代器传递参数

如果给迭代器的next()方法传递参数，那么这个参数会代替生成器内部上一条yield语句的返回值。

```
function *createIterator() {
    let first = yield 1;
    let second = yield first + 2;
    yield second + 3;
}

let iterator = createIterator();
console.log(iterator.next());
console.log(iterator.next(4));
console.log(iterator.next(5));
console.log(iterator.next());
输出结果：
{ value: 1, done: false }
{ value: 6, done: false }
{ value: 8, done: false }
{ value: undefined, done: true }
```



# 10 在迭代器中抛出错误

迭代器可以通过主动抛出错误来终止迭代过程：

```
function *createIterator() {
    let first = yield 1;
    let second = yield first + 2;
    yield second + 3;
}

let iterator = createIterator();
console.log(iterator.next());
console.log(iterator.next(4));
console.log(iterator.throw(new Error("boom"))); //迭代器抛出错误后，下面的语句永远无法执行
console.log(iterator.next(5));  
console.log(iterator.next());
```



可以通过捕获并处理迭代器抛出的错误，从而实现即使抛出错误，程序也能继续执行的目的

```
function *createIterator() {
    let first = yield 1;
    let second;
    try {
        second = yield first + 2;
    }catch (e) {
        second = 6;
    }
    yield second + 3;
}

let iterator = createIterator();
console.log(iterator.next());
console.log(iterator.next(4));
console.log(iterator.throw(new Error("boom"))); console.log(iterator.next(5));
console.log(iterator.next());
输出结果：
{ value: 1, done: false }
{ value: 6, done: false }
{ value: 9, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
```



# 11 示例：异步任务执行

**简单任务执行器**

```
function run(taskDef) {

    //创建一个无使用限制的迭代器
    let task = taskDef();

    //开始执行任务
    let result = task.next();

    //循环调用next()函数
    function step(){
        //如果任务未完成，则继续执行
        if(!result.done){
            result = task.next();
            step()
        }
    }

    //开始执行迭代
    step()
}

run(function *() {
   console.log('aaa');
   yield ;
   console.log('bbb');
   yield ;
   console.log('ccc');
});
输出结果：
aaa
bbb
ccc
```



**向任务执行器传递数据**

```
function run(taskDef) {

    //创建一个无使用限制的迭代器
    let task = taskDef();

    //开始执行任务
    let result = task.next();

    //循环调用next()函数
    function step(){
        //如果任务未完成，则继续执行
        if(!result.done){
            result = task.next(result.value);
            step()
        }
    }

    //开始执行迭代
    step()
}

run(function *() {
   let value = yield 1;
   console.log(value);
   value = yield value + 3;
   console.log(value)
});
```