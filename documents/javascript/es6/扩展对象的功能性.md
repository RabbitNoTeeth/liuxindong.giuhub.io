[TOC]



# 1 对象类别

ES6规范定义了四种对象：

1. 普通对象

   具有JavaScript对象所有的默认行为。

2. 特异对象

   具有某些与默认行为不符的内部行为。

3. 标准对象

   ES6规范中定义的对象，如Array、Date等，标准对象既可以是普通对象，也可以是特异对象。

4. 内建对象

   脚本开始执行时存在于JavaScript执行环境中的对象，所有的标准对象都是内建对象。



# 2 对象字面量语法扩展

## 2.1 属性初始值简写

通过ES6的属性初始化简写语法，可以消除属性名称和局部变量之间的重复书写。

```
//----- ES5
function person1(name,age) {
    return {
        name: name,
        age: age
    }
}

//-----ES6
function person2(name,age) {
    return {
        name,
        age
    }
}
```



## 2.2 对象方法的简写语法

ES6中对象方法的简写语法中，可以使用super关键字。

```
//----- ES5
let person1 = {
    name: 'liuxindong',
    sayHi: function () {
        console.log('hi , i am ',name)
    }
};

//-----ES6
let person2 = {
    name: 'liuxindong',
    sayHi() {
        console.log('hi , i am ',name)
    }
};
```

通过对象方法简写语法创建的方法有一个name属性，值为小括号之前的名称，对于上述示例，person2.sayHi()方法的name属性值为sayHi



## 2.3 可计算属性名

示例：

```
let name = 'firstName';

let person = {
    [name]: 'liu'
};

console.log(person.name);
console.log(person[name]);
console.log(person.firstName);
console.log(person['firstName']);

输出结果：
undefined
liu
liu
liu
```



在对象字面量中使用方括号表示的该属性名称是可计算的，它的内容将被求值并被最终转化为一个字符串，因而同样可以使用表达式作为属性的可计算名称：

```
let suffix = 'name';

let person = {
    ['first' + suffix]: 'liu',
    ['last' + suffix]: 'xindong'
};

console.log(person.firstname);
console.log(person['firstname']);
console.log(person.lastname);
console.log(person['lastname']);

输出结果：
liu
liu
xindong
xindong
```



# 3 新增方法

## 3.1 Object.is()

ES6引入了`Object.is()`方法来弥补全等运算符的不准确运算，这个方法接受两个参数，如果这两个参数的参数类型相同并且具有相同的值，那么返回true。

`Object.is()`方法的运行结果大部分情况下与===运算符一样，唯一的区别在于 +0 和 -0 的判断及NaN的判断。

```
console.log(+0 == -0);
console.log(+0 === -0);
console.log(Object.is(+0,-0));

console.log(NaN == NaN);
console.log(NaN === NaN);
console.log(Object.is(NaN,NaN));

输出结果：
true
true
false

false
false
true
```



## 3.2 Object.assgin()

`Object.assgin()`方法接受一个接收对象和任意数量的源对象，并按照指定的顺序将属性复制到接收对象中，如果多个源对象具有同名属性，则排位靠后的源对象会覆盖排位靠前的，最后返回接收对象。

```
let receiver = {};

Object.assign(receiver,
    {
        name: 'jack',
        age: 25
    },
    {
        name: 'rose',
        phone: '123123'
    }
);

console.log(receiver);

输出结果：
{ name: 'rose', age: 25, phone: '123123' }
```



# 4 重复的对象字面量属性

ES中移除了重复属性检查，无论是否严格模式，对于每一组的重复属性，都会选取最后一个取值：

```
let person = {
    name: 'jack',
    name: 'rose'
};

console.log(person);

输出结果：
{ name: 'rose' }
```



# 5 自有属性枚举顺序

ES6严格规定了对象的自有属性被枚举时的返回顺序：

1. 所有的数字按升序排序。
2. 所有的字符串按照它们被加入对象的顺序排序。
3. 所有的symbol键按照它们被加入对象的顺序排序。

这会影响到`Object.getOwnPropertyNames()`方法及`Reflect.ownKeys`返回属性的方式，`Object.assign()`方法处理属性的顺序也将随之改变。



示例：

```
let obj = {
    a: 1,
    0: 1,
    c: 1,
    2: 1,
    b: 1,
    1: 1
};

console.log(Object.getOwnPropertyNames(obj).join(""));

输出结果：
012acd
```



**注意：**对于for-in循环，由于并非所有的厂商都遵循相同的实现方式，因此仍未指定一个明确的枚举顺序。而`Object.keys()`方法和`JSON.stringify()`方法都指明与for-in使用相同的枚举顺序，因此它们的枚举顺序目前也不明确。



# 6 改变对象的原型

ES6中添加了`Object.setPrototypeOf()`方法，可以改变任意对象的原型，它接受两个参数：被改变原型的对象以及替代第一个参数原型的对象。



示例：

```
let person = {
    getGreeting(){
        console.log('hello!')
    }
};

let dog = {
    getGreeting(){
        console.log('woo!')
    }
};

let friend = Object.create(person);
friend.getGreeting();
console.log(Object.getPrototypeOf(friend) === person);

Object.setPrototypeOf(friend,dog);
friend.getGreeting();
console.log(Object.getPrototypeOf(friend) === dog);
输出结果：
hello!
true
woo!
true
```



# 7 简化原型访问的super引用

ES6引入了super关键字，简单来说，super引用相当于指向对象原型的指针，实际上也就是`Object.getPrototypeOf(this)`的值。



示例：

```
let person = {
    getGreeting(){
        return 'hello';
    }
};

let friend = {
    getGreeting(){
        console.log(super.getGreeting() + ', lalala!')
    }
};

Object.setPrototypeOf(friend,person);
friend.getGreeting();
```



注意：必须要在使用简写方法的对象中使用super引用，示例如下：

```
let friend = {
    getGreeting(){
        console.log(super.getGreeting() + ', lalala!')  //语法正确
    }
};

let friend = {
    getGreeting: function(){
        console.log(super.getGreeting() + ', lalala!')  //语法错误
    }
};
```



# 8 正式的方法定义

ES中正式定义了方法的概念：一个函数，它会有一个内部的[HomeObject]属性来容纳这个方法从属的对象。



示例:

```
let person = {
    // getGreeting1是方法
    getGreeting1(){
        return 'hello';
    }
};

// getGreeting2不是方法
function getGreeting2(){
    return 'hello';
}
```