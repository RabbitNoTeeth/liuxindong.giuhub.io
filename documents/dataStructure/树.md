# 1 定义

树是n(n>=0)个结点的有限集。n=0时称为空树。在任意一棵非空树中：
(1) 有且只有一个特定的称为根的结点。
(2) 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2 .... Tm,其中每一个集合本身又是一棵树，称为根的子树。
![](./resources/5.1.png)

## 1.1 结点分类

结点拥有的子树数称为结点的度（Degree)。
度为0的结点称为叶结点或终端结点。度不为0的结点称为非终端结点或分支结点，除根节点外，分支结点也称为内部节点。
树的度是树内各结点的度的最大值。
![](./resources/5.2.png)



## 1.2 结点关系

结点的子树的根称为该结点的孩子（child），该结点称为孩子的
双亲（parent)。

同一个双亲的孩子之间互为兄弟（sibling)。
结点的祖先是从根到该结点所经分支上的所有结点。
以某结点为根的子树中的任一结点都称为该结点的子孙。
![](./resources/5.3.png)



## 1.3 结点层次

结点的层次从根开始定义起，根为第一层，孩子为第二层。
树中结点的最大层次称为树的深度（depth)或高度。
![](./resources/5.4.png)



## 1.4 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称树为有序树，否则称为无序树。



## 1.5 森林是m(m>0)棵至不相交的树的集合。



# 2 存储结构

## 2.1 双亲表示法

在每个结点中，附设一个指示器指示其双亲结点到链表中的位置

![](./resources/5.5.png)



### 2.1.1 以数组作为存储结构为例

![](./resources/5.6.png)
该结构可以很快找到双亲结点，但是如果要找孩子结点则需遍历整个结构。



### 2.1.2 如果实际场景中更关注孩子节点，可增加相关指针，如下结构

![](./resources/5.7.png)



### 2.1.3 如果更关注兄弟节点，可优化为如下结构

![](./resources/5.8.png)
总之，存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于运算是否适合，是否方便，时间复杂度等。



## 2.2 孩子表示法

每个结点有多个指针域，其中每个指针指向一棵子树的根结点，称为多重链表表示法。
结点结构如下：

![](./resources/5.9.png)



### 2.2.1 方案一

![](./resources/5.10.png)
如果各结点的度相差较大，会导致很严重的空间浪费。



### 2.2.2 方案二

每个结点指针域的个数等于该结点的度，用专门的位置来存储结点的度。

![](./resources/5.11.png)
解决了空间浪费的问题，但各结点链表结构不同，加上度的维护，运算上带来了时间的损耗。



### 2.2.3 方案三

把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，放入一维数组中。
![](./resources/5.12.png)

该结构对于查找孩子结点或兄弟结点，以及遍历树结构都非常方便，但是查找双亲结点却很麻烦。



### 2.2.4 方案四

双亲孩子表示法

![](./resources/5.13.png)

解决了查找双案结点麻烦的问题



## 2.3 孩子兄弟表示法

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的，因此，设置两个指针，分别指向第一个孩子结点和右兄弟结点。
![](./resources/5.14.png)
查找孩子节点时，只需通过firstchild找到第一个孩子结点，然后通过rightsib查找其它孩子节点。
如果有必要，也可加入parent指针域来解决查找双亲结点的问题。

该表示法最大的好处是将一棵复杂的树变成了一棵二叉树，将上图稍做变形
![](./resources/5.15.png)







