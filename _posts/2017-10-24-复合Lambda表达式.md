---
title: 复合Lambda表达式
tags: 
- java
- java8
- Lambda
---

# 1.概念

将多个简单的Lambda表达式复合成复杂的表达式



# 2.示例

## 2.1 比较器复合

### 2.1.1 逆序

上一节实战中的例子是按照weight属性来给苹果进行升序排序，我们想要升序排序之后再降序排序，如何实现呢？使用api提供的Comparator的默认方法reversed

```
public void test3(){
        System.out.println("----- before sort -----");
        List<Apple> appleList = test1();

        System.out.println("----- after sort -----");
        appleList.sort(Comparator.comparing(Apple::getWeight));
        printList(appleList,(Apple apple) -> System.out.println(apple));

        System.out.println("----- reverse sort -----");                       //插入新的代码
        appleList.sort(Comparator.comparing(Apple::getWeight).reversed());    //使用reversed方法逆序
        printList(appleList,(Apple apple) -> System.out.println(apple));
    }
```



输出结果：

![控制台结果]({{ "assets/illustration/20171024/1505315599467.png" | absolute_url }})



### 2.1.2 比较器链

想要在重量排序后在按照颜色对苹果进行排序，可以使用api中的Comparator.thenComparing

```
appleList.sort(Comparator.comparing(Apple::getWeight).thenComparing(Apple::getColor));
```



## 2.2 谓词复合

谓词接口包括三个方法：negate，and，or，让你可以重用已有的Predicate来创建更复杂的谓词

```
Predicate<Apple> redApple = (Apple apple) -> apple.getColor().equals("red");
Predicate<Apple> notRedApple = redApple.negate();
Predicate<Apple> redAndHeavyApple = redApple.and((Apple apple) -> apple.getWeight()>150);
Predicate<Apple> redAndHeavyAppleOrGreen = redApple.and((Apple apple) -> apple.getWeight()>150)
                                                   .or((Apple apple) -> apple.getColor().equals("green"));
```



## 2.3 函数复合（可实现流水线式的操作）

api中Function接口谓词配置了andThen和compose两个默认方法

```
Function<Integer,Integer> f = x -> x+1;
Function<Integer,Integer> g = x -> x*2;
Function<Integer,Integer> h1 = f.andThen(g);
System.out.println(h1.apply(2));        //输出为 6
Function<Integer,Integer> h2 = f.compose(g);
System.out.println(h2.apply(2));        //输出为 5
```

